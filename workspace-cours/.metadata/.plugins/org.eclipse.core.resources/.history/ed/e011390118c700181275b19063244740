package cryptologie;

import java.util.Arrays;
import java.util.List;

public class Enigma {

	static String MESSAGE = "le chat ronronne";
	static List<String> ALPHABET = Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
			"o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z");

	static List<Integer> FIRSTROTOR = Arrays.asList(1, 2);
	static List<Integer> SECONDROTOR = Arrays.asList(1, 2, 3, 4);
	static List<Integer> THIRDROTOR = Arrays.asList(1, 2, 3);

	public static void main(String[] args) {
		System.out.println("Rot<pos> de : " + MESSAGE);
		String encodeString = encodeString(MESSAGE);
		System.out.println("Encode : " + encodeString);
		System.out.println("Decode : " + decodeString(encodeString));
	}

	private static String encodeString(String message) {
		return code(message, true);
	}

	private static String decodeString(String message) {
		return code(message, false);
	}

	/*
	 * on prend la position des rotor a la lettre (exemple : test, S est la 3eme
	 * lettre, donc on va tourner de 3 crans les 3 rotor donc 1 3 3 Ensuite on
	 * applique la formule position de la lettre + 1 3 3 modulo 26
	 * 
	 * idée : On fait monter un itérateur, racine caré, si le résultat est pair ou
	 * impair
	 */

	private static String code(String message, Boolean encode) {
		StringBuilder result = new StringBuilder();
		if (message != null) {
			message = message.toLowerCase();
			List<String> splitedChar = Arrays.asList(message.split("(?!^)"));
			Integer iterator = 1;
			Integer position = null;

			for (String letter : splitedChar) {

				int rotor = rotor(iterator);

				if (!ALPHABET.contains(letter)) {
					result.append(letter);
				} else if (encode) {
					position = (ALPHABET.indexOf(letter) + iterator) % ALPHABET.size();
					if (position >= 26) {
						position = 0;
					}
					result.append(ALPHABET.get(position));
				} else if (!encode) {
					position = (ALPHABET.indexOf(letter) - iterator) % ALPHABET.size();
					if (position < 0) {
						position = position + 26;
					}
					result.append(ALPHABET.get(position));
				}
				iterator++;
			}
		} else {
			return "Message null";
		}
		return result.toString();
	}

	/**
	 * @param iterator
	 * @return the value of concatenation of rotors
	 */
	private static int rotor(int iterator) {

		StringBuilder rotor = new StringBuilder();

		int firstRotor = checkRotorValue(FIRSTROTOR, iterator);
		rotor.append(FIRSTROTOR.get(firstRotor - 1).toString());

		int secondRotor = checkRotorValue(SECONDROTOR, iterator);
		rotor.append(SECONDROTOR.get(secondRotor - 1).toString());

		int thirdRotor = checkRotorValue(THIRDROTOR, iterator);
		rotor.append(THIRDROTOR.get(thirdRotor - 1).toString());

		return Integer.parseInt(rotor.toString());
	}

	/**
	 * @param rotor
	 * @param iterator
	 * @return the value according to rotor size
	 */
	private static int checkRotorValue(List<Integer> rotor, int iterator) {
		if (rotor.size() <= iterator) {
			int result = iterator;
			while (rotor.size() <= iterator && result != 0) {
				result = rotor.size() % result;
			}
			if (result == 0) {
				return 1;
			} else {
				return result + 1;
			}
		}
		return iterator;
	}

}
